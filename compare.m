
function  [] = compare(calibration, fig1, fig2)
%m = load('calibration.mat');
%m = load(calibration);
%m1 = load('other1.mat');
m1 = load(fig2);
% lr.mat is the left and right skeletons generated by python
%left_right_points = load('lr.mat');
%left_right_points = load(fig1);
% Get world points (x,y,z) using triangulate 
%worldPoints = triangulate(left_right_points.l,left_right_points.r,m.stereoParams);
% worldPoints =  worldPoints/1000
%anchors = triangulate(left_right_points.al,left_right_points.ar,m.stereoParams) - worldPoints(1:1,:);
%worldPoints = worldPoints - worldPoints(1:1,:)
[worldPoints, order] = triangulateOpenpose(calibration, fig1);
worldPoints = worldPoints - worldPoints(1:1,:);

% Split points to start and end points
q1 = worldPoints(1:2:end,:);
q2 = worldPoints(2:2:end,:);

q3 = m1.both(1:2:end,:);
q4 = m1.both(2:2:end,:);

% Concat each start and end point to [[start, end] , [start, end], ...,
% [start, end]] list then  plot 3D points on viewer with 
% 3D line between each point
figure('Name', 'fig1')
for elm = transpose(cat(2, q1,q2))
    plot3([elm(1);elm(4)], [elm(2);elm(5)], [elm(3);elm(6)],  'Color', [255, 153, 51] / 255, 'MarkerSize', 30, 'LineWidth', 3);
    hold on;
end
figure('Name', 'fig2')
for elm = transpose(cat(2, q3,q4))
    plot3([elm(1);elm(4)], [elm(2);elm(5)], [elm(3);elm(6)],  'Color', [51, 153, 255] / 255, 'MarkerSize', 30, 'LineWidth', 3);
    hold on;
end
